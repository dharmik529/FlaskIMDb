#!/usr/bin/env python3
"""
Azure ACR Vulnerability Remediation Automation

This script automates the process of identifying and patching vulnerable container images
in Azure Container Registry by integrating with a CSO vulnerability API endpoint.
"""

import json
import logging
import os
import subprocess
import sys
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import requests
from azure.containerregistry import ContainerRegistryClient
from azure.identity import DefaultAzureCredential
from azure.core.exceptions import ResourceNotFoundError
import yaml

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class VulnerabilityRemediator:
    """Main class for handling ACR vulnerability remediation"""
    
    def __init__(self, config_path: str = "config.yaml"):
        """Initialize the remediation system with configuration"""
        self.config = self._load_config(config_path)
        self.credential = DefaultAzureCredential()
        self.registry_client = ContainerRegistryClient(
            endpoint=f"https://{self.config['acr_name']}.azurecr.io",
            credential=self.credential
        )
        
    def _load_config(self, config_path: str) -> Dict:
        """Load configuration from YAML file"""
        try:
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            logger.error(f"Config file {config_path} not found")
            sys.exit(1)
            
    def fetch_vulnerable_images(self) -> List[Dict]:
        """Fetch list of vulnerable images from CSO API endpoint"""
        try:
            response = requests.get(
                self.config['cso_api_endpoint'],
                headers={'Authorization': f"Bearer {self.config.get('api_token', '')}"},
                timeout=30
            )
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            logger.error(f"Failed to fetch vulnerable images: {e}")
            return []
            
    def analyze_vulnerability(self, vuln_image: Dict) -> Dict:
        """Analyze vulnerability details and determine remediation strategy"""
        return {
            'image': vuln_image['image'],
            'tag': vuln_image.get('tag', 'latest'),
            'severity': vuln_image.get('severity', 'medium'),
            'vulnerabilities': vuln_image.get('vulnerabilities', []),
            'base_image': self._extract_base_image(vuln_image['image']),
            'remediation_strategy': self._determine_strategy(vuln_image)
        }
        
    def _extract_base_image(self, image_name: str) -> Optional[str]:
        """Extract base image from Dockerfile or image metadata"""
        try:
            # Pull and inspect the image
            manifest = self.registry_client.get_manifest_properties(
                repository=image_name.split(':')[0],
                tag_or_digest=image_name.split(':')[1] if ':' in image_name else 'latest'
            )
            # In practice, you'd parse the image layers to find the base
            return "alpine:latest"  # Placeholder
        except Exception as e:
            logger.warning(f"Could not extract base image: {e}")
            return None
            
    def _determine_strategy(self, vuln_image: Dict) -> str:
        """Determine the best remediation strategy based on vulnerability type"""
        severity = vuln_image.get('severity', 'medium').lower()
        
        if severity == 'critical':
            return 'rebuild_immediate'
        elif severity == 'high':
            return 'update_base_rebuild'
        elif severity == 'medium':
            return 'update_packages'
        else:
            return 'monitor'
            
    def create_patched_dockerfile(self, analysis: Dict) -> str:
        """Generate a patched Dockerfile based on vulnerability analysis"""
        base_image = analysis['base_image'] or 'alpine:latest'
        
        dockerfile_content = f"""# Auto-generated Dockerfile for vulnerability remediation
# Original image: {analysis['image']}
# Generated: {datetime.now().isoformat()}

FROM {base_image}

# Update base image packages
RUN apt-get update && apt-get upgrade -y && apt-get clean || \
    apk update && apk upgrade || \
    yum update -y && yum clean all || \
    dnf update -y && dnf clean all

# Apply specific vulnerability patches
"""
        
        # Add specific package updates based on vulnerabilities
        for vuln in analysis['vulnerabilities']:
            if vuln.get('package'):
                dockerfile_content += f"RUN apt-get install -y {vuln['package']}={vuln.get('fixed_version', 'latest')} || \\\n"
                dockerfile_content += f"    apk add {vuln['package']}={vuln.get('fixed_version', 'latest')} || \\\n"
                dockerfile_content += f"    yum install -y {vuln['package']}-{vuln.get('fixed_version', 'latest')}\n\n"
                
        # Copy application files (customize based on your needs)
        dockerfile_content += """
# Copy application files
COPY . /app
WORKDIR /app

# Set appropriate user
RUN adduser -D -u 1000 appuser || useradd -u 1000 appuser
USER appuser

# Define entrypoint
ENTRYPOINT ["/app/entrypoint.sh"]
"""
        
        return dockerfile_content
        
    def build_and_push_image(self, dockerfile_content: str, image_name: str, new_tag: str) -> bool:
        """Build the patched image and push to ACR"""
        try:
            # Create temporary directory for build
            import tempfile
            with tempfile.TemporaryDirectory() as tmpdir:
                dockerfile_path = os.path.join(tmpdir, 'Dockerfile')
                
                # Write Dockerfile
                with open(dockerfile_path, 'w') as f:
                    f.write(dockerfile_content)
                    
                # Build image
                build_cmd = [
                    'docker', 'build',
                    '-t', f"{self.config['acr_name']}.azurecr.io/{image_name}:{new_tag}",
                    '-f', dockerfile_path,
                    tmpdir
                ]
                
                logger.info(f"Building image: {' '.join(build_cmd)}")
                result = subprocess.run(build_cmd, capture_output=True, text=True)
                
                if result.returncode != 0:
                    logger.error(f"Build failed: {result.stderr}")
                    return False
                    
                # Push to ACR
                push_cmd = [
                    'docker', 'push',
                    f"{self.config['acr_name']}.azurecr.io/{image_name}:{new_tag}"
                ]
                
                logger.info(f"Pushing image: {' '.join(push_cmd)}")
                result = subprocess.run(push_cmd, capture_output=True, text=True)
                
                if result.returncode != 0:
                    logger.error(f"Push failed: {result.stderr}")
                    return False
                    
                return True
                
        except Exception as e:
            logger.error(f"Build/push failed: {e}")
            return False
            
    def scan_new_image(self, image_name: str, tag: str) -> Dict:
        """Scan the newly built image for vulnerabilities"""
        # This would integrate with Azure Defender or your scanning tool
        scan_cmd = [
            'az', 'acr', 'repository', 'show-manifests',
            '--name', self.config['acr_name'],
            '--repository', image_name
        ]
        
        try:
            result = subprocess.run(scan_cmd, capture_output=True, text=True)
            # Parse scan results
            return {'status': 'clean', 'vulnerabilities': []}
        except Exception as e:
            logger.error(f"Scan failed: {e}")
            return {'status': 'error', 'message': str(e)}
            
    def update_deployment_manifests(self, image_name: str, old_tag: str, new_tag: str) -> None:
        """Update Kubernetes/deployment manifests with new image tag"""
        # This would update your K8s manifests, Helm charts, etc.
        logger.info(f"Updating deployments: {image_name}:{old_tag} -> {image_name}:{new_tag}")
        
        # Example: Update K8s deployment
        if self.config.get('update_k8s_deployments'):
            update_cmd = [
                'kubectl', 'set', 'image',
                f"deployment/{image_name}",
                f"{image_name}={self.config['acr_name']}.azurecr.io/{image_name}:{new_tag}",
                '--all-namespaces'
            ]
            subprocess.run(update_cmd)
            
    def notify_teams(self, message: str, severity: str = 'info') -> None:
        """Send notification to teams about remediation status"""
        if self.config.get('teams_webhook'):
            webhook_url = self.config['teams_webhook']
            
            color = {
                'success': '00FF00',
                'warning': 'FFA500',
                'error': 'FF0000',
                'info': '0000FF'
            }.get(severity, '0000FF')
            
            payload = {
                '@type': 'MessageCard',
                '@context': 'https://schema.org/extensions',
                'summary': 'ACR Vulnerability Remediation Update',
                'themeColor': color,
                'sections': [{
                    'activityTitle': 'Vulnerability Remediation Status',
                    'text': message,
                    'facts': [
                        {'name': 'Timestamp', 'value': datetime.now().isoformat()},
                        {'name': 'Registry', 'value': self.config['acr_name']}
                    ]
                }]
            }
            
            try:
                requests.post(webhook_url, json=payload)
            except Exception as e:
                logger.error(f"Failed to send Teams notification: {e}")
                
    def remediate_image(self, vuln_image: Dict) -> bool:
        """Main remediation workflow for a single image"""
        logger.info(f"Starting remediation for {vuln_image['image']}")
        
        # Analyze vulnerability
        analysis = self.analyze_vulnerability(vuln_image)
        
        if analysis['remediation_strategy'] == 'monitor':
            logger.info(f"Low severity vulnerabilities in {vuln_image['image']}, monitoring only")
            return True
            
        # Generate patched Dockerfile
        dockerfile = self.create_patched_dockerfile(analysis)
        
        # Generate new tag
        new_tag = f"{analysis['tag']}-patched-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        # Build and push
        image_name = analysis['image'].split(':')[0]
        if self.build_and_push_image(dockerfile, image_name, new_tag):
            # Scan new image
            scan_result = self.scan_new_image(image_name, new_tag)
            
            if scan_result['status'] == 'clean':
                # Update deployments
                self.update_deployment_manifests(image_name, analysis['tag'], new_tag)
                
                # Notify success
                self.notify_teams(
                    f"Successfully patched {image_name}:{analysis['tag']} -> {new_tag}",
                    'success'
                )
                return True
            else:
                self.notify_teams(
                    f"New image {image_name}:{new_tag} still has vulnerabilities",
                    'warning'
                )
                return False
        else:
            self.notify_teams(
                f"Failed to build/push patched image for {image_name}",
                'error'
            )
            return False
            
    def run(self) -> None:
        """Main execution loop"""
        logger.info("Starting ACR vulnerability remediation process")
        
        # Fetch vulnerable images
        vulnerable_images = self.fetch_vulnerable_images()
        logger.info(f"Found {len(vulnerable_images)} vulnerable images")
        
        # Process each image
        success_count = 0
        for vuln_image in vulnerable_images:
            try:
                if self.remediate_image(vuln_image):
                    success_count += 1
            except Exception as e:
                logger.error(f"Failed to remediate {vuln_image['image']}: {e}")
                
        # Final report
        message = f"Remediation complete: {success_count}/{len(vulnerable_images)} images patched successfully"
        logger.info(message)
        self.notify_teams(message, 'info')


# Configuration file template
CONFIG_TEMPLATE = """
# ACR Vulnerability Remediation Configuration

# Azure Container Registry name
acr_name: myregistry

# CSO Vulnerability API endpoint
cso_api_endpoint: https://cso-api.company.com/api/v1/vulnerabilities

# API authentication token (use Azure Key Vault in production)
api_token: ${API_TOKEN}

# Microsoft Teams webhook for notifications
teams_webhook: https://company.webhook.office.com/webhookb2/...

# Update Kubernetes deployments automatically
update_k8s_deployments: true

# Severity thresholds
auto_remediate_severity:
  - critical
  - high

# Excluded images (regex patterns)
exclude_patterns:
  - ".*-dev$"
  - "test-.*"
"""


if __name__ == "__main__":
    # Create config template if it doesn't exist
    if not os.path.exists("config.yaml"):
        with open("config.yaml", "w") as f:
            f.write(CONFIG_TEMPLATE)
        logger.info("Created config.yaml template. Please update with your settings.")
        sys.exit(0)
        
    # Run remediation
    remediator = VulnerabilityRemediator()
    remediator.run()
